No global state, at least initially no closures, meaning it's easy to see where
mutability happens.  No functions as such, instead 'transformations', using two
argument lists, one for immutable indata, one for mutable outdata.

add :: (int, int) -> (int)
(a, b) add (c) {
  c = a + b
}

Out arguments are passed by reference, indata by unspecified means. I believe
this lack of specification should not change anything, as the data is
immutable.

Transforms can be overloaded based on all arguments, which allows convenient
things like writing an initialize function for all datatypes that may require
initialization, without requiring them all to have different names.

Providing two overloads where the only thing that differentiates them is the
type of number, for example float and int, should probably give at least
a warning, as providing a literal number might not give the intended effect.

It might be nice if transformations were flexible, in the way that if you have
an argument of a type, the transformation actually only requires the argument
to have those names with the correct types. Different versions of the
transformation would be generated for each of those, and it would provide some
sense of polymorphism, but with practically zero cost.

type Point struct {
  x, y int
}

type Square struct {
  x, y, width, height int
}

distance :: (Point, Point) -> (float)
(a, b) distance (dist) {
  (a*a + b*b) sqrt (dist)
}

distance would then for example work on both Point and Square. Disadvantages of
this method is that it can cause multiple overloads to be applicable to the
same argument lists. This should probably be at least a warning, quite possibly
an error. If this is used it should probably be possible to mark a transform as
strict, ie it requires the exact type, if it does something weird or just wants
some sanity. If the latter is a common reason the the default should perhaps be
the other way around, or the feature should be altogether dropped.

Custom allocators should be supported, but I don't really know all that much
about them, so I can't say very much. For now I'll just use malloc and friends.

I want no exceptions, error handling is go-like.

Declaring a local variable puts it on the stack. Assignment to a struct via '='
is either a shallow copy or disallowed, not sure which. Probably shallow copy,
keeping everything consistent. Possibly a warning for a shallow copy when the
struct contains an owned pointer.

varname Point // a stack-allocated (possibly optimized away) Point struct. Zero-initialized or not?
varname Point {
    x = 42
    y = 3
  } // same as before, but now with x initialized to 42 and y initialized to 3
varname Point {x = 42, y = 3} // same as above
varname Point = Point {x = 42, y = 3} // same as above
varname := Point {x = 42, y = 3} // inference perhaps?
varname Point {42, 3} // probably same as above
varname Point {x = 42} // leaves y uninitialized or zeroed
varname Point {42} // compile time error or same as above?
varname = Point {42, 3} // assigns the x and y in varname to those in the given struct. Actually shallow copy of rvalue

type Intlist struct {
  cap uint8
  !int elems
}

The ! is an example of possible syntax to denote an owned pointer. The only
thing it means is that the autogenerated dealloc/destroy will free the memory
to which it points. It could also generate extra warnings when you try to do
something weird, that may require annotations to silence to show that you've
actually thought it through.

Some transforms are autogenerated. Examples include dealloc/destroy and move.
Given Intlist above:

dealloc :: () -> (Intlist)
() dealloc (list) {
  () free (list.elems)
}

move :: () -> (Intlist, Intlist)
() move (from, to) {
  to.elems, from.elems = from.elems, null
  to.cap = from.cap
}

Syntax for freeing and allocating on heap is uncertain, it might be done as
automatically supplied transforms or as special syntax. Transforms would be
rather nice from a design viewpoint.

malloc, calloc, realloc and free would be typesafe automatically generated
transforms. If generics are allowed it might look like this:

malloc :: () -> (*t)
() malloc (p) {
  //actual malloc call like:
  //p = malloc(sizeof(t));
}
malloc :: (uint) -> (*t)
(count) malloc (p) {
  //actual malloc call like:
  //p = malloc(sizeof(t)*count);
}
calloc :: () -> (*t)
() calloc (p) {
  //actual calloc call like:
  //p = calloc(sizeof(t))
}
calloc :: (uint) -> (*t)
(count) calloc (p) {
  //actual calloc call like:
  //p = calloc(sizeof(t)*count);
}
realloc :: (uint) -> (*t)
(count) realloc (p) {
  //actual realloc call like:
  //p = realloc(p, sizeof(t)*count);
}

All of these may fail, but most of the time they work. It should probably be
fine to have these overloads that just explode if the returned pointer is null
(at least in debug), as well as another overload that additionally provides an
outargument for reporting the error.

It may or may not be a good idea to change the names, since it might confuse
people that the count parameter is kinda nice.

It might be nice to treat pointers to continuous chunks of memory as something
different from normal pointers. malloc will have to keep track of the size of
a memoryblock, meaning the extra information of how long the chunk is isn't
actually extra, it will just be stored twice until malloc is replaced (if it
is).

malloc (uint) -> ([]t)
(count) malloc (chunkPointer) {
  chunkPointer.cap = count
  //chunkPointer = malloc(sizeof(t)*count);
}

In that case pointer[2] would not be allowed, but chunkPointer[2] would.
*chunkPointer would probably not be allowed.

Having some sort way to use a function/transform in an expression position is
probably necessary for ease of use. It should only be doable when there is only
one outargument, otherwise it seems kinda hard to define. Additionally these
functions should probably be restricted to pure functions, and possibly even to
'simple' types, ints, floats, bools, etc.

It may seem a strange limitation that it should only work with simple types,
but it would take care of most important cases, but prevent things that may
hide some complexity or memory usage. Not sure about this.

It has become apparent that some nice way to provide a reference to something
internal to a datastructure would be nice. Overloading [] might be the way to
go, it would allow things like matrix[row, col] to be a reference to the
datacell in question. Alternatively transforms with a singe outargument of type
*t where t is some type might be allowed as lvalues, in which case things would
be written to the actual value. Example:

type Matrix<n> struct {
  cells ![]n
  ncols uint
}

read :: (Matrix<n>, uint, uint) -> (n)
(m, row, col) read (v) {
  v = m.cells[row * m.ncols + col]
}

read :: (Matrix<n>, uint, uint) -> (*n)
(m, row, col) read (p) {
  p = &m.cells[row * m.ncols + col]
}

// These two would then be equivalent
factor := 42
read(matrix, 3, 2) *= factor
read(matrix, 3, 2) = read(matrix, 3, 2) * factor

Alternatively we just realize that we can dereference the pointer to get
a usable lvalue (which then needs to be supported, but we already knew that) to
get what we want:

*read(matrix, 3, 2) *= factor

This of course assumes that the type system can select the correct variation of
read based on its 'return type'.
